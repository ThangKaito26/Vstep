<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luy·ªán thi Vstep c√πng AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #4f46e5; /* Indigo-600 */
            --primary-hover: #4338ca; /* Indigo-700 */
            --secondary: #10b981; /* Emerald-500 */
            --success: #22c55e; /* Green-500 */
            --warning: #f59e0b; /* Amber-500 */
            --danger: #ef4444; /* Red-500 */
            --text-primary: #1e293b; /* Slate-800 */
            --text-secondary: #475569; /* Slate-600 */
            --surface: #ffffff;
            --surface-alt: #f1f5f9; /* Slate-100 */
            --border: #e2e8f0; /* Slate-200 */
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }

        html.dark {
            --text-primary: #f1f5f9; /* Slate-100 */
            --text-secondary: #94a3b8; /* Slate-400 */
            --surface: #1e293b; /* Slate-800 */
            --surface-alt: #334155; /* Slate-700 */
            --border: #475569; /* Slate-600 */
        }
        
        html.dark body {
            background-color: #0f172a; /* Slate-900 */
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23334155' fill-opacity='0.4'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }
        
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            background-color: #f8fafc; /* Slate-50 */
            color: var(--text-primary);
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23e2e8f0' fill-opacity='0.4'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            background-attachment: fixed;
        }

        .main-container { max-width: 1000px; margin: 2rem auto; padding: 0 1rem; }
        .header { text-align: center; margin-bottom: 2rem; }
        .header h1 { font-size: 2.5rem; font-weight: 700; }
        .header h1 span { background: linear-gradient(to right, var(--primary), var(--secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1.125rem; color: var(--text-secondary); margin-top: 0.5rem; }
        
        .main-card { background-color: var(--surface); border-radius: 1.5rem; padding: 2rem; box-shadow: var(--shadow-lg); }
        .skill-section { border: 1px solid var(--border); border-radius: 1rem; padding: 1.5rem; margin-bottom: 1.5rem; transition: all 0.3s ease; }
        .skill-section:hover { border-color: var(--primary); box-shadow: var(--shadow); }
        .skill-title { font-size: 1.5rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1.25rem; display: flex; align-items: center; gap: 0.75rem; }
        .practice-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 1rem; }
        .practice-btn { background-color: var(--surface-alt); border: 1px solid var(--border); border-radius: 0.75rem; padding: 0.75rem 1rem; text-align: center; font-weight: 500; cursor: pointer; transition: all 0.2s ease; display: block; width: 100%; }
        .practice-btn:hover { transform: translateY(-2px); box-shadow: var(--shadow); border-color: var(--primary); color: var(--primary); }
        
        .content-area { margin-top: 2rem; padding-bottom: 100px; /* Add padding to prevent content from being hidden behind sticky controls */ }
        .loading-overlay { position: absolute; inset: 0; background: hsla(222, 47%, 11%, 0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; border-radius: 1.5rem; transition: opacity .3s ease; backdrop-filter: blur(4px); }
        .loading-spinner { width: 48px; height: 48px; border: 4px solid var(--border); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 1rem; }
        .loading-text { color: var(--primary-light); font-weight: 600; font-size: 1.125rem; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .info-card { background: var(--surface-alt); border: 1px solid var(--border); border-radius: 16px; padding: 1.5rem; margin-bottom: 1.5rem; }
        .textarea-input { width: 100%; min-height: 200px; padding: 1rem; border-radius: 12px; border: 2px solid var(--border); font-size: 1rem; resize: vertical; background-color: var(--surface); color: var(--text-primary); }
        .textarea-input:focus { outline: none; border-color: var(--primary); }
        .primary-btn { background-color: var(--primary); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; }
        .primary-btn:hover { background-color: var(--primary-hover); }
        .primary-btn:disabled { background-color: var(--text-secondary); cursor: not-allowed; }
        .secondary-btn { background-color: var(--surface-alt); color: var(--text-primary); border: 1px solid var(--border); padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; }
        .secondary-btn:hover { background-color: var(--border); }

        .vstep-question { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem; }
        .vstep-question-text { font-size: 1.1rem; font-weight: 500; margin-bottom: 1rem; line-height: 1.6; }
        .vstep-options { display: flex; flex-direction: column; gap: 0.75rem; }
        .vstep-option { text-align: left; padding: 0.75rem 1.25rem; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.2s ease; }
        .vstep-option:hover { background: var(--primary-light); border-color: var(--primary); }
        .vstep-option.selected { background-color: var(--primary-light); border-color: var(--primary); }
        
        .vstep-option.correct { background-color: #dcfce7 !important; border-color: var(--success) !important; color: #166534 !important; font-weight: 600; }
        .vstep-option.incorrect { background-color: #fee2e2 !important; border-color: var(--danger) !important; color: #991b1b !important; }
        
        html.dark .vstep-option.correct { background-color: #14532d !important; border-color: #4ade80 !important; color: #bbf7d0 !important; }
        html.dark .vstep-option.incorrect { background-color: #991b1b !important; border-color: #f87171 !important; color: #fecaca !important; }

        .vstep-reading-layout { display: flex; flex-direction: column; }
        @media (min-width: 768px) {
            .vstep-reading-layout { flex-direction: row; gap: 1.5rem; max-height: 80vh; }
            .vstep-reading-passage { flex: 6; overflow-y: auto; padding-right: 1.5rem; border-right: 1px solid var(--border); line-height: 1.7; }
            .vstep-reading-questions { flex: 4; overflow-y: auto; }
        }

        .sticky-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--surface);
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            z-index: 50;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        html.dark .sticky-controls {
             box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.3);
        }
        .sticky-controls-wrapper {
            max-width: 1000px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .audio-status-indicator {
            font-weight: 600;
            color: var(--primary);
            flex-grow: 1;
            text-align: left;
        }
        .control-buttons {
            display: flex;
            gap: 1rem;
        }

        /* --- NEW: Mind Map Styles --- */
        .mind-map-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            padding: 1.5rem;
        }
        .mind-map-topic {
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            box-shadow: var(--shadow);
        }
        .mind-map-sub-points {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
        }
        .mind-map-sub-point {
            background: var(--surface-alt);
            border: 1px solid var(--border);
            padding: 0.75rem 1.25rem;
            border-radius: 12px;
            font-weight: 500;
        }


        .word-count { text-align: right; font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem; }
        .record-btn { background-color: var(--danger); }
        .record-btn.recording { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        .hidden { display: none; }
        .card-title-alt { font-size: 1.1rem; font-weight: 600; margin-top: 1rem; margin-bottom: .5rem; color: var(--text-primary); }
        .score-circle { width: 100px; height: 100px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem; font-size: 2rem; font-weight: 700; border-width: 5px; border-style: solid; }

        /* Custom styles for listening section */
        .listening-section-container {
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .listening-script-toggle-btn {
            background-color: var(--surface-alt);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 1rem;
        }
        .listening-script-toggle-btn:hover {
            background-color: var(--border);
        }
        .listening-script-content {
            margin-top: 1rem;
            padding: 1rem;
            background-color: var(--surface-alt);
            border-radius: 0.75rem;
            border: 1px solid var(--border);
            font-size: 0.95rem;
            line-height: 1; /* Reduced line height for closer lines */
            white-space: pre-wrap; /* Preserve line breaks */
            word-break: break-word; /* Break long words */
        }
        .listening-sentence-play-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.25rem 0.6rem;
            border-radius: 0.25rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-right: 0.5rem; /* Margin to the right of the button */
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            vertical-align: middle; /* Align button vertically with text */
        }
        .listening-sentence-play-btn:hover {
            background-color: var(--primary-hover);
        }
        .listening-sentence {
            display: block; /* Each sentence on a new line */
            margin-bottom: -2.2rem; /* Reduced margin-bottom for closer sentences */
            line-height: 1.2; /* Adjusted line-height for the sentence itself */
        }
    </style>
</head>
<body class="transition-colors duration-300">

    <div class="main-container">
        <header class="header relative">
             <div class="absolute top-0 right-0">
                <button id="theme-toggle" class="p-2 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:text-gray-400">
                    <svg id="theme-toggle-dark-icon" class="hidden h-6 w-6" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8 0 1010.586 10.586z"></path></svg>
                    <svg id="theme-toggle-light-icon" class="hidden h-6 w-6" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 100 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
                </button>
            </div>
            <h1>Luy·ªán thi <span>Vstep</span> c√πng AI</h1>
            <p>C√¥ng c·ª• luy·ªán thi Vstep to√†n di·ªán, ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi AI</p>
        </header>

        <div class="main-card">
            <div class="text-center mb-8">
                 <label for="vstepTopicInput" class="block font-semibold mb-2 text-lg text-gray-700 dark:text-gray-300">Nh·∫≠p ch·ªß ƒë·ªÅ ƒë·ªÉ t·∫°o b√†i luy·ªán t·∫≠p:</label>
                 <div class="flex justify-center items-center gap-2 max-w-lg mx-auto">
                    <input type="text" id="vstepTopicInput" class="flex-grow p-3 border-2 border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-center text-lg focus:border-primary focus:ring-primary" placeholder="V√≠ d·ª•: technology, environment, education...">
                    <button id="clearTopicBtn" class="secondary-btn px-4 py-3 text-sm">X√≥a</button>
                    <button id="pasteTopicBtn" class="secondary-btn px-4 py-3 text-sm">D√°n</button>
                 </div>
            </div>

            <!-- Listening Section -->
            <div class="skill-section">
                <h3 class="skill-title">üéß Luy·ªán Nghe <span class="text-sm font-normal text-gray-500 dark:text-gray-400 ml-auto">~40 ph√∫t</span></h3>
                <div class="practice-grid">
                    <button class="practice-btn" data-skill="listening" data-part="1">Ph·∫ßn 1: Th√¥ng b√°o ng·∫Øn</button>
                    <button class="practice-btn" data-skill="listening" data-part="2">Ph·∫ßn 2: H·ªôi tho·∫°i</button>
                    <button class="practice-btn" data-skill="listening" data-part="3">Ph·∫ßn 3: B√†i gi·∫£ng</button>
                </div>
            </div>

            <!-- Reading Section -->
            <div class="skill-section">
                <h3 class="skill-title">üìñ Luy·ªán ƒê·ªçc <span class="text-sm font-normal text-gray-500 dark:text-gray-400 ml-auto">60 ph√∫t</span></h3>
                <div class="practice-grid grid-cols-1">
                    <button class="practice-btn" data-skill="reading">T·∫°o b√†i ƒë·ªçc & c√¢u h·ªèi</button>
                </div>
            </div>

            <!-- Writing Section -->
            <div class="skill-section">
                <h3 class="skill-title">‚úçÔ∏è Luy·ªán Vi·∫øt <span class="text-sm font-normal text-gray-500 dark:text-gray-400 ml-auto">60 ph√∫t</span></h3>
                <div class="practice-grid grid-cols-2">
                    <button class="practice-btn" data-skill="writing" data-task="1">Task 1: Vi·∫øt th∆∞</button>
                    <button class="practice-btn" data-skill="writing" data-task="2">Task 2: Vi·∫øt lu·∫≠n</button>
                </div>
            </div>
            
            <!-- Speaking Section -->
            <div class="skill-section">
                <h3 class="skill-title">üéôÔ∏è Luy·ªán N√≥i <span class="text-sm font-normal text-gray-500 dark:text-gray-400 ml-auto">~12 ph√∫t</span></h3>
                <div class="practice-grid">
                    <button class="practice-btn" data-skill="speaking" data-part="1">Ph·∫ßn 1: T∆∞∆°ng t√°c x√£ h·ªôi</button>
                    <button class="practice-btn" data-skill="speaking" data-part="2">Ph·∫ßn 2: Th·∫£o lu·∫≠n gi·∫£i ph√°p</button>
                    <button class="practice-btn" data-skill="speaking" data-part="3">Ph·∫ßn 3: Ph√°t tri·ªÉn ch·ªß ƒë·ªÅ</button>
                </div>
            </div>
        </div>

        <div id="content-area" class="content-area"></div>
    </div>

    <script>
        // --- Theme Toggle Logic ---
        const themeToggleBtn = document.getElementById('theme-toggle');
        const applyTheme = () => {
            if (localStorage.getItem('color-theme') === 'dark' || (!('color-theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
                document.getElementById('theme-toggle-light-icon').classList.remove('hidden');
                document.getElementById('theme-toggle-dark-icon').classList.add('hidden');
            } else {
                document.documentElement.classList.remove('dark');
                document.getElementById('theme-toggle-dark-icon').classList.remove('hidden');
                document.getElementById('theme-toggle-light-icon').classList.add('hidden');
            }
        };
        themeToggleBtn.addEventListener('click', function() {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('color-theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
            applyTheme();
        });
        
        // --- Global State ---
        let isSpeaking = false;
        let recognition;
        let isRecording = false;
        let accumulatedTranscript = '';
        let availableVoices = []; // To store available voices
        let currentAudioQueue = []; // To manage audio playback for individual sentences
        let currentAudioIndex = 0; // To track current audio in queue

        // --- NEW: Function to load voices ---
        function loadVoices() {
            availableVoices = speechSynthesis.getVoices().filter(voice => voice.lang.startsWith('en'));
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            applyTheme();
            // Pre-load voices and set up listener
            if ('speechSynthesis' in window) {
                loadVoices();
                if (speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = loadVoices;
                }
            }
            const buttons = document.querySelectorAll('.practice-btn');
            buttons.forEach(button => {
                button.addEventListener('click', handlePracticeRequest);
            });

            // Add event listeners for clear and paste buttons
            document.getElementById('clearTopicBtn').addEventListener('click', () => {
                document.getElementById('vstepTopicInput').value = '';
            });
            document.getElementById('pasteTopicBtn').addEventListener('click', async () => {
                try {
                    const text = await navigator.clipboard.readText();
                    document.getElementById('vstepTopicInput').value = text;
                } catch (err) {
                    console.error('Failed to read clipboard contents: ', err);
                    // Using a custom message in the UI instead of alert
                    const inputElement = document.getElementById('vstepTopicInput');
                    inputElement.placeholder = 'Kh√¥ng th·ªÉ d√°n t·ª´ clipboard. Vui l√≤ng d√°n th·ªß c√¥ng.';
                    inputElement.classList.add('border-red-500', 'ring-red-500');
                    setTimeout(() => {
                        inputElement.classList.remove('border-red-500', 'ring-red-500');
                        inputElement.placeholder = 'V√≠ d·ª•: technology, environment, education...';
                    }, 3000);
                }
            });
        });

        const contentArea = document.getElementById('content-area');

        function getTopic() {
            const topic = document.getElementById('vstepTopicInput').value.trim();
            if (!topic) {
                // Changed alert to a more user-friendly message in the UI
                const inputElement = document.getElementById('vstepTopicInput');
                inputElement.classList.add('border-red-500', 'ring-red-500'); // Highlight input
                inputElement.placeholder = 'Vui l√≤ng nh·∫≠p m·ªôt ch·ªß ƒë·ªÅ!';
                setTimeout(() => {
                    inputElement.classList.remove('border-red-500', 'ring-red-500');
                    inputElement.placeholder = 'V√≠ d·ª•: technology, environment, education...';
                }, 3000); // Remove highlight after 3 seconds
                return null;
            }
            return topic;
        }

        function showGeneratingScreen(skillName) {
            contentArea.innerHTML = `
                <div class="main-card relative">
                    <div class="loading-overlay flex">
                         <div class="loading-spinner"></div>
                         <p class="loading-text ml-4">AI ƒëang t·∫°o b√†i ${skillName}, vui l√≤ng ch·ªù trong gi√¢y l√°t...</p>
                    </div>
                    <div class="h-64"></div>
                </div>
            `;
            contentArea.scrollIntoView({ behavior: 'smooth' });
        }
        
        // --- Main Handler ---
        async function handlePracticeRequest(event) {
            const button = event.currentTarget;
            const skill = button.dataset.skill;
            const topic = getTopic();
            if (!topic) return;

            switch(skill) {
                case 'listening':
                    const partL = button.dataset.part;
                    showGeneratingScreen(`Luy·ªán Nghe Ph·∫ßn ${partL}`);
                    try {
                        const data = await generateListeningTest(topic, partL);
                        renderListeningUI(data, partL);
                    } catch (error) {
                        handleError(error, 'nghe');
                    }
                    break;
                case 'reading':
                    showGeneratingScreen('Luy·ªán ƒê·ªçc');
                     try {
                        const data = await generateReadingTest(topic);
                        renderReadingUI(data);
                    } catch (error) {
                        handleError(error, 'ƒë·ªçc');
                    }
                    break;
                case 'writing':
                    const task = button.dataset.task;
                    showGeneratingScreen(`Luy·ªán Vi·∫øt Task ${task}`);
                    try {
                        const data = await generateWritingTest(topic, task);
                        renderWritingUI(data, task);
                    } catch (error) {
                        handleError(error, 'vi·∫øt');
                    }
                    break;
                case 'speaking':
                    const partS = button.dataset.part;
                    showGeneratingScreen(`Luy·ªán N√≥i Ph·∫ßn ${partS}`);
                    try {
                        const data = await generateSpeakingTest(topic, partS);
                        renderSpeakingUI(data, partS);
                    } catch (error) {
                        handleError(error, 'n√≥i');
                    }
                    break;
            }
        }
        
        function handleError(error, skillName) {
             contentArea.innerHTML = `<div class="main-card text-center text-red-500 font-bold">L·ªói t·∫°o b√†i ${skillName}: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i v·ªõi m·ªôt ch·ªß ƒë·ªÅ kh√°c.</div>`;
             console.error(error);
        }

        // --- RENDERERS ---
        function renderListeningUI(data, part) {
            const partTitle = part === '1' ? 'Th√¥ng b√°o ng·∫Øn' : (part === '2' ? 'H·ªôi tho·∫°i' : 'B√†i gi·∫£ng');
            let sectionsHTML = '';
            
            data.forEach((section, sectionIndex) => {
                // Normalize whitespace in the audio script before splitting into sentences
                let cleanedAudioScript = section.audio_script
                    .replace(/[\r\n]+/g, ' ') // Replace one or more newlines with a single space
                    .replace(/\s{2,}/g, ' ') // Replace two or more spaces with a single space
                    .trim(); // Trim leading/trailing spaces from the whole script

                // Split audio_script into sentences for individual playback
                // Simple split by . ! ? followed by space or end of string.
                // The \s* will now only match a single space if it exists, due to prior cleaning.
                const sentences = cleanedAudioScript.match(/[^.!?]+[.!?]\s*|$[^.!?]*$/g).filter(s => s.trim().length > 0);

                sectionsHTML += `
                    <div class="listening-section-container" data-section-index="${sectionIndex}">
                        <h4 class="text-xl font-semibold mb-4">B√†i nghe ${sectionIndex + 1}</h4>
                        <div class="flex justify-between items-center mb-4">
                            <button class="primary-btn play-section-audio-btn" data-audio-script="${section.audio_script}">
                                Ph√°t to√†n b·ªô ƒëo·∫°n n√†y
                            </button>
                            <button class="listening-script-toggle-btn" data-target="script-content-${sectionIndex}">
                                ·∫®n/Hi·ªán VƒÉn b·∫£n
                            </button>
                        </div>
                        <div id="script-content-${sectionIndex}" class="listening-script-content hidden">
                            ${sentences.map((sentence, sIdx) => `
                                <span class="listening-sentence" data-sentence-index="${sIdx}">
                                    <button class="listening-sentence-play-btn" data-sentence="${sentence.trim()}">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                                            <path fill-rule="evenodd" d="M4.5 5.653c0-1.426 1.529-2.33 2.779-1.643l11.54 6.348c1.295.712 1.295 2.566 0 3.278L7.28 19.991c-1.25.687-2.779-.217-2.779-1.643V5.653z" clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    ${sentence.trim()}
                                </span>
                            `).join('')}
                        </div>
                `;
                section.questions.forEach((q) => {
                    sectionsHTML += `
                        <div class="vstep-question" data-question-id="${q.id}" data-correct-answer="${q.correct_answer}">
                            <p class="vstep-question-text">${q.id}. ${q.question}</p>
                            <div class="vstep-options">
                                ${q.options.map((opt) => `<button class="vstep-option" data-value="${opt}">${opt}</button>`).join('')}
                            </div>
                        </div>
                    `;
                });
                sectionsHTML += `</div>`; // Close listening-section-container
            });

            contentArea.innerHTML = `
                <div class="main-card">
                    <h3 class="skill-title">üéß Luy·ªán Nghe - Ph·∫ßn ${part}: ${partTitle}</h3>
                    <div id="test-result-summary" class="hidden"></div>
                    <div class="info-card"><p class="font-semibold text-center">ƒê·ªçc tr∆∞·ªõc c√°c c√¢u h·ªèi. Nh·∫•n "B·∫Øt ƒë·∫ßu nghe to√†n b·ªô" ƒë·ªÉ ph√°t t·∫•t c·∫£ c√°c ƒëo·∫°n √¢m thanh.</p></div>
                    <div id="listening-sections-area">${sectionsHTML}</div>
                </div>
                <!-- Sticky Controls -->
                <div id="sticky-controls-container" class="sticky-controls">
                    <div class="sticky-controls-wrapper">
                        <div id="audio-status" class="audio-status-indicator">S·∫µn s√†ng</div>
                        <div class="control-buttons">
                            <button id="startAllAudioBtn" class="secondary-btn">B·∫Øt ƒë·∫ßu nghe to√†n b·ªô</button>
                            <button id="stopAudioBtn" class="secondary-btn hidden">D·ª´ng ph√°t √¢m</button>
                            <button id="submitTestBtn" class="primary-btn">N·ªôp b√†i</button>
                        </div>
                    </div>
                </div>
            `;
            
            attachOptionListeners('listening-sections-area');

            // Event listener for toggling script visibility
            document.querySelectorAll('.listening-script-toggle-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const targetId = e.target.dataset.target;
                    document.getElementById(targetId).classList.toggle('hidden');
                    e.target.textContent = document.getElementById(targetId).classList.contains('hidden') ? 'Hi·ªán VƒÉn b·∫£n' : '·∫®n VƒÉn b·∫£n';
                });
            });

            // Event listener for playing individual sentences
            document.querySelectorAll('.listening-sentence-play-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const sentence = e.target.closest('.listening-sentence-play-btn').dataset.sentence;
                    speechSynthesis.cancel(); // Stop any ongoing speech
                    isSpeaking = false; // Reset global speaking flag
                    await speakText(sentence);
                });
            });

            // Event listener for playing a whole section's audio
            document.querySelectorAll('.play-section-audio-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const audioScript = e.target.dataset.audioScript;
                    speechSynthesis.cancel(); // Stop any ongoing speech
                    isSpeaking = false; // Reset global speaking flag
                    const audioStatusEl = document.getElementById('audio-status');
                    audioStatusEl.textContent = 'ƒêang ph√°t ƒëo·∫°n n√†y...';
                    try {
                        await speakText(audioScript);
                        audioStatusEl.textContent = 'ƒê√£ ph√°t xong ƒëo·∫°n n√†y.';
                    } catch (error) {
                        audioStatusEl.textContent = 'L·ªói ph√°t √¢m thanh.';
                        console.error("Error playing section audio:", error);
                    }
                });
            });


            const startAllAudioBtn = document.getElementById('startAllAudioBtn');
            const stopBtn = document.getElementById('stopAudioBtn');
            const submitBtn = document.getElementById('submitTestBtn');
            const audioStatusEl = document.getElementById('audio-status');

            startAllAudioBtn.addEventListener('click', () => {
                startAllAudioBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                startAllAudioBtn.disabled = true;
                playAudioQueue(data.map(d => d.audio_script), audioStatusEl, () => {
                    stopBtn.classList.add('hidden');
                    startAllAudioBtn.classList.remove('hidden');
                    startAllAudioBtn.disabled = false;
                    startAllAudioBtn.textContent = "Nghe l·∫°i to√†n b·ªô";
                });
            });

            stopBtn.addEventListener('click', () => {
                speechSynthesis.cancel();
                isSpeaking = false;
                audioStatusEl.textContent = 'ƒê√£ d·ª´ng ph√°t √¢m.';
                stopBtn.classList.add('hidden');
                startAllAudioBtn.classList.remove('hidden');
                startAllAudioBtn.disabled = false;
            });

            submitBtn.addEventListener('click', () => {
                handleSubmitTest('listening-sections-area');
                document.getElementById('sticky-controls-container').classList.add('hidden');
            });
        }

        function renderReadingUI(data) {
            let questionsHTML = '';
            data.questions.forEach((q) => {
                questionsHTML += `
                    <div class="vstep-question" data-question-id="${q.id}" data-correct-answer="${q.correct_answer}">
                        <p class="vstep-question-text">${q.id}. ${q.question}</p>
                        <div class="vstep-options">
                            ${q.options.map((opt) => `<button class="vstep-option" data-value="${opt}">${opt}</button>`).join('')}
                        </div>
                    </div>
                `;
            });

            contentArea.innerHTML = `
                 <div class="main-card">
                    <h3 class="skill-title">üìñ Luy·ªán ƒê·ªçc: ${data.title}</h3>
                    <div id="test-result-summary" class="hidden"></div>
                    <div class="vstep-reading-layout">
                        <div class="vstep-reading-passage">${data.passage.replace(/\n/g, '<br><br>')}</div>
                        <div class="vstep-reading-questions" id="reading-question-area">${questionsHTML}</div>
                    </div>
                </div>
                <!-- Sticky Controls -->
                <div id="sticky-controls-container" class="sticky-controls">
                     <div class="sticky-controls-wrapper">
                        <div class="audio-status-indicator"></div> <!-- Placeholder for alignment -->
                        <div class="control-buttons">
                            <button id="submitTestBtn" class="primary-btn">N·ªôp b√†i</button>
                        </div>
                    </div>
                </div>
            `;
            attachOptionListeners('reading-question-area');
            document.getElementById('submitTestBtn').addEventListener('click', () => {
                handleSubmitTest('reading-question-area');
                document.getElementById('sticky-controls-container').classList.add('hidden');
            });
        }
        
        function renderWritingUI(data, task) {
             contentArea.innerHTML = `
                <div class="main-card">
                    <h3 class="skill-title">‚úçÔ∏è Luy·ªán Vi·∫øt - Task ${task}</h3>
                    <div class="info-card">
                        <p class="font-semibold text-lg">ƒê·ªÅ b√†i:</p>
                        <div class="italic mt-2 text-gray-800 dark:text-gray-200 text-base leading-relaxed">${data.prompt.replace(/\n/g, '<br>')}</div>
                    </div>
                    <textarea id="writing-input" class="textarea-input" placeholder="Vi·∫øt b√†i c·ªßa b·∫°n ·ªü ƒë√¢y..."></textarea>
                    <p id="word-count" class="word-count">S·ªë t·ª´: 0</p>
                    <div class="text-center mt-6">
                        <button id="analyzeWritingBtn" class="primary-btn">Ph√¢n t√≠ch b√†i vi·∫øt b·∫±ng AI</button>
                    </div>
                    <div id="writing-analysis-area" class="mt-4"></div>
                </div>
            `;
            const writingInput = document.getElementById('writing-input');
            const wordCount = document.getElementById('word-count');
            writingInput.addEventListener('input', () => {
                const count = writingInput.value.trim().split(/\s+/).filter(Boolean).length;
                wordCount.textContent = `S·ªë t·ª´: ${count}`;
            });
            document.getElementById('analyzeWritingBtn').addEventListener('click', async () => {
                const analysisArea = document.getElementById('writing-analysis-area');
                analysisArea.innerHTML = '<div class="loading-spinner mx-auto my-4"></div>';
                try {
                    const analysis = await analyzeWriting(writingInput.value, task);
                    analysisArea.innerHTML = `
                        <div class="info-card">
                            <h4 class="text-xl font-semibold mb-2">Ph√¢n t√≠ch c·ªßa AI</h4>
                            <p class="mt-1"><strong>M·ª©c ƒë·ªô ho√†n th√†nh:</strong> ${analysis.taskFulfillment}</p>
                            <p class="mt-1"><strong>B·ªë c·ª•c:</strong> ${analysis.organization}</p>
                            <p class="mt-1"><strong>T·ª´ v·ª±ng:</strong> ${analysis.vocabulary}</p>
                            <p class="mt-1"><strong>Ng·ªØ ph√°p:</strong> ${analysis.grammar}</p>
                            <p class="mt-2 text-lg"><strong>ƒêi·ªÉm ∆∞·ªõc l∆∞·ª£ng:</strong> <span class="font-bold text-indigo-600 dark:text-indigo-400">${analysis.estimatedScore}/10</span></p>
                        </div>
                    `;
                } catch(e) {
                     analysisArea.innerHTML = `<p class="text-red-500 text-center font-bold">L·ªói ph√¢n t√≠ch b√†i vi·∫øt: ${e.message}</p>`;
                }
            });
        }
        
        function renderSpeakingUI(data, part) {
            let contentHTML = '';
            let taskPrompt = '';
            switch(part) {
                case '1':
                    taskPrompt = `Ch·ªß ƒë·ªÅ 1: ${data.topic1_title}. Ch·ªß ƒë·ªÅ 2: ${data.topic2_title}`;
                    contentHTML = `
                        <div class="info-card">
                            <h4 class="card-title-alt text-lg">Ch·ªß ƒë·ªÅ 1: ${data.topic1_title}</h4>
                            <ul class="list-disc list-inside ml-4 mt-2 space-y-1">${data.topic1_questions.map(q => `<li>${q}</li>`).join('')}</ul>
                        </div>
                         <div class="info-card">
                            <h4 class="card-title-alt text-lg">Ch·ªß ƒë·ªÅ 2: ${data.topic2_title}</h4>
                            <ul class="list-disc list-inside ml-4 mt-2 space-y-1">${data.topic2_questions.map(q => `<li>${q}</li>`).join('')}</ul>
                        </div>
                    `;
                    break;
                case '2':
                    taskPrompt = `T√¨nh hu·ªëng: ${data.situation}`;
                    contentHTML = `
                        <div class="info-card">
                            <h4 class="card-title-alt text-lg">T√¨nh hu·ªëng:</h4>
                            <p class="mt-2">${data.situation}</p>
                            <h4 class="card-title-alt mt-4 text-lg">C√°c gi·∫£i ph√°p g·ª£i √Ω:</h4>
                            <ul class="list-disc list-inside ml-4 mt-2 space-y-1">${data.options.map(opt => `<li>${opt}</li>`).join('')}</ul>
                        </div>
                    `;
                    break;
                case '3':
                    taskPrompt = `Ch·ªß ƒë·ªÅ: ${data.topic}`;
                    contentHTML = `
                        <div class="info-card">
                            <h4 class="card-title-alt text-lg text-center">Ch·ªß ƒë·ªÅ: ${data.topic}</h4>
                            <div class="mind-map-container">
                                <div class="mind-map-topic">${data.idea_map.main_idea}</div>
                                <div class="mind-map-sub-points">
                                    ${data.idea_map.sub_points.map(point => `<div class="mind-map-sub-point">${point}</div>`).join('')}
                                </div>
                            </div>
                            <h4 class="card-title-alt mt-6 text-lg">C√¢u h·ªèi ph·ª•:</h4>
                            <ul class="list-disc list-inside ml-4 mt-2 space-y-1">${data.follow_up_questions.map(q => `<li>${q}</li>`).join('')}</ul>
                        </div>
                    `;
                    break;
            }

            contentArea.innerHTML = `
                <div class="main-card" data-task-prompt="${taskPrompt}">
                    <h3 class="skill-title">üéôÔ∏è Luy·ªán N√≥i - Ph·∫ßn ${part}</h3>
                    <div id="speaking-analysis-area" class="hidden"></div>
                    ${contentHTML}
                    <div id="speaking-controls" class="text-center mt-6 flex justify-center items-center gap-4">
                        <button id="start-record-btn" class="primary-btn">B·∫Øt ƒë·∫ßu ghi √¢m</button>
                        <button id="stop-record-btn" class="primary-btn record-btn hidden">N·ªôp b√†i & Ch·∫•m ƒëi·ªÉm</button>
                    </div>
                    <div id="speaking-status" class="text-center mt-4 font-semibold"></div>
                </div>
            `;
            
            document.getElementById('start-record-btn').addEventListener('click', handleAdvancedRecording);
            document.getElementById('stop-record-btn').addEventListener('click', handleAdvancedRecording);
        }

        // --- SCORING & INTERACTION ---
        function attachOptionListeners(containerId) {
            const container = document.getElementById(containerId);
            container.addEventListener('click', (e) => {
                if (e.target.classList.contains('vstep-option')) {
                    const optionsContainer = e.target.parentElement;
                    // Deselect other options in the same question
                    optionsContainer.querySelectorAll('.vstep-option').forEach(btn => btn.classList.remove('selected'));
                    // Select the clicked option
                    e.target.classList.add('selected');
                }
            });
        }

        function handleSubmitTest(containerId) {
            const container = document.getElementById(containerId);
            const questions = container.querySelectorAll('.vstep-question');
            let score = 0;
            
            questions.forEach(q => {
                const correctAnswer = q.dataset.correctAnswer;
                const selectedOption = q.querySelector('.vstep-option.selected');
                const allOptions = q.querySelectorAll('.vstep-option');

                allOptions.forEach(opt => {
                    opt.disabled = true; // Disable all options
                    const optValue = opt.dataset.value;
                    // Highlight the correct answer
                    if (optValue === correctAnswer) {
                        opt.classList.add('correct');
                    }
                });

                if (selectedOption) {
                    if (selectedOption.dataset.value === correctAnswer) {
                        score++;
                    } else {
                        selectedOption.classList.add('incorrect');
                    }
                }
            });
            
            const summaryEl = document.getElementById('test-result-summary');
            const percentage = questions.length > 0 ? Math.round((score / questions.length) * 100) : 0;
            let scoreColor = 'var(--danger)';
            let scoreBg = '#fee2e2';
            let scoreText = '#991b1b';
            
            if (document.documentElement.classList.contains('dark')) {
                scoreBg = '#991b1b';
                scoreText = '#fecaca';
            }


            if (percentage >= 80) {
                scoreColor = 'var(--success)';
                scoreBg = '#dcfce7';
                scoreText = '#166534';
                if (document.documentElement.classList.contains('dark')) {
                    scoreBg = '#14532d';
                    scoreText = '#bbf7d0';
                }
            } else if (percentage >= 50) {
                scoreColor = 'var(--warning)';
                scoreBg = '#fef3c7';
                scoreText = '#92400e';
                if (document.documentElement.classList.contains('dark')) {
                    scoreBg = '#78350f';
                    scoreText = '#fde68a';
                }
            }

            summaryEl.innerHTML = `
                <div class="info-card border-2 border-indigo-500 text-center">
                    <h4 class="text-xl font-bold text-indigo-700 dark:text-indigo-300 mb-4">K·∫øt qu·∫£ b√†i l√†m</h4>
                    <div class="score-circle" style="border-color: ${scoreColor}; background-color: ${scoreBg}; color: ${scoreText};">
                        ${score}
                    </div>
                    <p class="text-xl font-bold">B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng ${score} tr√™n t·ªïng s·ªë ${questions.length} c√¢u.</p>
                    <p class="text-lg text-gray-600 dark:text-gray-400">(ƒê·∫°t ${percentage}%)</p>
                </div>
            `;
            summaryEl.classList.remove('hidden');
            summaryEl.scrollIntoView({ behavior: 'smooth' });

            const submitBtn = document.getElementById('submitTestBtn');
            if(submitBtn) submitBtn.disabled = true;
        }


        // =================================================================
        // AI & GENERATION LOGIC
        // =================================================================
        
        async function callGemini(prompt, schema = null) {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            if (schema) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: schema
                };
            }
            const apiKey = "AIzaSyByNgUKCZKSKYMLUV7AhkxRKcWG2mBxAyI"; // The API key is provided by the environment at runtime.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({ error: { message: response.statusText } }));
                    console.error("API Error Response:", errorBody);
                    throw new Error(`L·ªói API: ${errorBody.error?.message || `Status ${response.status}`}`);
                }

                const result = await response.json();
                
                if (!result.candidates || result.candidates.length === 0) {
                     console.error("Response has no candidates:", result);
                     if (result.promptFeedback?.blockReason) {
                         throw new Error(`Y√™u c·∫ßu b·ªã ch·∫∑n v√¨ l√Ω do: ${result.promptFeedback.blockReason}. Vui l√≤ng th·ª≠ ch·ªß ƒë·ªÅ kh√°c.`);
                     }
                     throw new Error('API kh√¥ng tr·∫£ v·ªÅ k·∫øt qu·∫£ h·ª£p l·ªá.');
                }
                
                const text = result.candidates[0]?.content?.parts?.[0]?.text;

                if (text && text.trim()) {
                    if (schema) {
                        return JSON.parse(text);
                    }
                    return text; // Return as plain text if no schema
                } else {
                    console.error("API response has no text content:", result);
                    const finishReason = result.candidates[0]?.finishReason;
                    if (finishReason === 'SAFETY') {
                        throw new Error('N·ªôi dung b·ªã ch·∫∑n v√¨ l√Ω do an to√†n. Vui l√≤ng th·ª≠ m·ªôt ch·ªß ƒë·ªÅ kh√°c.');
                    }
                    throw new Error('C·∫•u tr√∫c ph·∫£n h·ªìi API kh√¥ng mong ƒë·ª£i ho·∫∑c vƒÉn b·∫£n tr·ªëng.');
                }
            } catch (error) {
                console.error("Error in callGemini function:", error);
                if (error instanceof SyntaxError) {
                    throw new Error("L·ªói x·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ AI (JSON kh√¥ng h·ª£p l·ªá).");
                }
                throw error;
            }
        }
        
        async function generateListeningTest(topic, part) {
            let prompt;
            const schema = { type: "ARRAY", items: { type: "OBJECT", properties: { audio_script: { type: "STRING" }, questions: { type: "ARRAY", items: { type: "OBJECT", properties: { id: { type: "NUMBER" }, question: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correct_answer: { type: "STRING" } }, required: ["id", "question", "options", "correct_answer"] } } }, required: ["audio_script", "questions"] } };

            if (part === '1') {
                prompt = `Create a VSTEP Listening Part 1 test with 8 questions, based on the general topic: "${topic}".
Part 1 consists of 8 separate, short recordings. You must return a JSON array of 8 objects. Each object represents one recording and its corresponding question.

For each of the 8 objects, provide:
1. 'audio_script': A very short, simple English dialogue (2-3 turns between speakers) or a brief monologue. The script should be around 55-70 words long. The content should be a simple, everyday situation.
2. 'questions': An array containing exactly ONE question object.

The question object must have:
- 'id': A sequential number from 1 to 8.
- 'question': A direct question about a specific detail in the audio script (e.g., "What is the price?", "Where are they meeting?", "What did she buy?").
- 'options': An array of 4 short strings. One is the correct answer, and the other three are plausible distractors based on keywords mentioned in the script.
- 'correct_answer': The full string of the correct option.

IMPORTANT:
- Do NOT include any introductory text like "This is the listening test..." or "Now we are ready to start...". The 'audio_script' for each of the 8 items should ONLY contain the dialogue/monologue for that specific question.
- The language level must be A2-B1 CEFR.
- The 8 questions should be related to the general topic of "${topic}" but should cover different situations within that topic.`;
            } else if (part === '2') {
                prompt = `Create a VSTEP Listening Part 2 test based on the topic: "${topic}".
                - Structure: You must return a JSON array of 3 objects (for 3 conversations). Each object must have 'audio_script' (a dialogue of 60-90 seconds between 2 speakers), and a 'questions' array containing exactly 4 question objects.
                - Question Numbering: The 'id' for the questions must be sequential from 9 to 20 across all 3 conversations.
                - Each question object must have: "id", "question", "options" (4 strings), and "correct_answer".
                - The language level must be B1-B2 CEFR. The content must be strictly related to the topic.
                - Do NOT include any generic test instructions in the audio_script.`;
            } else if (part === '3') {
                prompt = `Create a VSTEP Listening Part 3 test based on the topic: "${topic}".
                - Structure: You must return a JSON array of 3 objects (for 3 lectures/talks). Each object must have 'audio_script' (a monologue of 90-120 seconds by 1 speaker), and a 'questions' array containing exactly 5 question objects.
                - Question Numbering: The 'id' for the questions must be sequential from 21 to 35 across all 3 talks.
                - Each question object must have: "id", "question", "options" (4 strings), and "correct_answer".
                - The language level must be B1-B2 CEFR. The content must be strictly related to the topic.
                - Do NOT include any generic test instructions in the audio_script.`;
            }
            
            return await callGemini(prompt, schema);
        }

        async function generateReadingTest(topic) {
            const prompt = `Create a complete VSTEP Reading test based on the topic: "${topic}".
            Return a single JSON object with: 
            1. "title": A suitable title for the passage.
            2. "passage": A well-structured academic-style passage of 450-500 words, at a B1-B2 CEFR level. The passage should be informative and engaging.
            3. "questions": An array of 10 multiple-choice question objects. Each question must have:
                - "id": A sequential number from 1 to 10.
                - "question": A clear question about the passage. The questions should cover a range of skills: main idea, specific details, vocabulary in context, inference, and author's purpose.
                - "options": An array of 4 strings (A, B, C, D). One is the correct answer, and the other three are plausible distractors.
                - "correct_answer": The full string of the correct option.`;
             const schema = { type: "OBJECT", properties: { title: { type: "STRING" }, passage: { type: "STRING" }, questions: { type: "ARRAY", items: { type: "OBJECT", properties: { id: { type: "NUMBER" }, question: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correct_answer: { type: "STRING" } }, required: ["id", "question", "options", "correct_answer"] } } }, required: ["title", "passage", "questions"] };
            return await callGemini(prompt, schema);
        }

        async function generateWritingTest(topic, task) {
            let prompt;
            let schema;

            if (task === '1') {
                prompt = `Create a VSTEP Writing Task 1 prompt based on the topic: "${topic}". The prompt must be realistic for an exam setting and follow the VSTEP format.
                Return a single JSON object with the following structure:
                {
                    "prompt_intro": "A brief introductory scenario (e.g., You received an email from your friend Mary...)",
                    "email_excerpt": "The actual email content from Mary (around 50-80 words, with an informal tone if from a friend, or formal if from a colleague/company).",
                    "instructions": "Clear instructions for the reply, including 3 key points that must be addressed in the letter, and the word count requirement (e.g., Write a reply to Mary. In your email, you have to tell her [point 1], [point 2], and [point 3]. You should write at least 120 words.)."
                }
                Ensure the email_excerpt and instructions are distinct and clearly separated. The content should be at a B1-B2 CEFR level.`;
                schema = { 
                    type: "OBJECT", 
                    properties: { 
                        prompt_intro: { type: "STRING" },
                        email_excerpt: { type: "STRING" },
                        instructions: { type: "STRING" }
                    }, 
                    required: ["prompt_intro", "email_excerpt", "instructions"] 
                };
            } else if (task === '2') {
                prompt = `Create a VSTEP Writing Task 2 prompt based on the topic: "${topic}". The prompt must be realistic for an exam setting.
                The prompt should present a clear topic, often a statement to agree or disagree with, or a problem with causes and solutions to discuss. It should encourage the use of specific reasons and examples. The essay should be about 250 words.
                Return a single JSON object with a "prompt" string containing the full instructions.`;
                schema = { type: "OBJECT", properties: { prompt: { type: "STRING" } }, required: ["prompt"] };
            }
            
            const rawResponse = await callGemini(prompt, schema);

            // Reconstruct the prompt string for rendering based on the new structure
            if (task === '1') {
                return {
                    prompt: `${rawResponse.prompt_intro}\n\n${rawResponse.email_excerpt}\n\n${rawResponse.instructions}`
                };
            } else {
                return rawResponse; // Task 2 already returns a single 'prompt' string
            }
        }
        
        async function generateSpeakingTest(topic, part) {
            const prompt = `Create a VSTEP Speaking Part ${part} test based on the topic: "${topic}". The topics should be common and accessible for B1-B2 learners.
            - If Part 1 (Social Interaction), return a JSON object with "topic1_title", "topic1_questions" (an array of 3-4 introductory questions), "topic2_title", and "topic2_questions" (an array of 3-4 questions on a different subject).
            - If Part 2 (Solution Discussion), return a JSON object with a "situation" (a clear problem) and an "options" array (3 distinct and viable solutions for the user to discuss and choose from).
            - If Part 3 (Topic Development), return a JSON object with "topic" (a broader concept), an "idea_map" object containing a "main_idea" string and a "sub_points" array of 3-4 strings, and "follow_up_questions" array (2-3 questions).`;
            let schema;
            if (part === '1') {
                schema = { type: "OBJECT", properties: { topic1_title: { type: "STRING" }, topic1_questions: { type: "ARRAY", items: { type: "STRING" } }, topic2_title: { type: "STRING" }, topic2_questions: { type: "ARRAY", items: { type: "STRING" } } }, required: ["topic1_title", "topic1_questions", "topic2_title", "topic2_questions"] };
            } else if (part === '2') {
                schema = { type: "OBJECT", properties: { situation: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } } }, required: ["situation", "options"] };
            } else { // Part 3
                schema = { type: "OBJECT", properties: { topic: { type: "STRING" }, idea_map: { type: "OBJECT", properties: { main_idea: { type: "STRING" }, sub_points: { type: "ARRAY", items: { type: "STRING" } } }, required: ["main_idea", "sub_points"] }, follow_up_questions: { type: "ARRAY", items: { type: "STRING" } } }, required: ["topic", "idea_map", "follow_up_questions"] };
            }
            return await callGemini(prompt, schema);
        }
        
        async function analyzeWriting(writingText, task) {
            const prompt = `As a VSTEP examiner, analyze the following English text for Writing Task ${task}. Provide detailed feedback in VIETNAMESE on: Task Fulfillment, Organization, Vocabulary, and Grammar. Then, give an estimated score out of 10. Return a JSON object with keys "taskFulfillment", "organization", "vocabulary", "grammar", and "estimatedScore".
            Text: ${writingText || "(No submission)"}`;
             const schema = { type: "OBJECT", properties: { taskFulfillment: { type: "STRING" }, organization: { type: "STRING" }, vocabulary: { type: "STRING" }, grammar: { type: "STRING" }, estimatedScore: { type: "NUMBER" } }, required: ["taskFulfillment", "organization", "vocabulary", "grammar", "estimatedScore"] };
            return await callGemini(prompt, schema);
        }

        async function analyzeSpeaking(taskPrompt, transcript) {
            const prompt = `As a VSTEP speaking examiner, analyze the user's spoken response.
            - The task/question was: "${taskPrompt}"
            - The user's transcribed response is: "${transcript}"
            Provide a score out of 100 for overall performance. Also give detailed feedback in Vietnamese, including positive points and areas for improvement (pronunciation, fluency, grammar, vocabulary). Finally, provide a corrected version of the user's transcript if there are errors.
            Return a JSON object with keys: "score" (number), "feedback" (string), "corrected_transcript" (string), "positive_points" (string), "areas_for_improvement" (string).`;
            const schema = { type: "OBJECT", properties: { score: { type: "NUMBER" }, feedback: { type: "STRING" }, corrected_transcript: { type: "STRING" }, positive_points: { type: "STRING" }, areas_for_improvement: { type: "STRING" } }, required: ["score", "feedback", "corrected_transcript", "positive_points", "areas_for_improvement"] };
            return await callGemini(prompt, schema);
        }

        // --- Audio & Recording Helpers (FIXED) ---
        function speakText(text) {
            return new Promise((resolve, reject) => {
                if (!('speechSynthesis' in window)) {
                    console.error('Browser does not support speech synthesis.');
                    return reject('Speech synthesis not supported');
                }
                
                // Ensure voices are loaded before speaking
                if (availableVoices.length === 0) {
                    loadVoices(); // Attempt to load them again if they were not ready initially
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US'; // Set language for better voice matching

                if (availableVoices.length > 0) {
                    // Prefer a Google US English voice if available
                    utterance.voice = availableVoices.find(v => v.name.includes('Google') && v.name.includes('US')) || availableVoices[0];
                } else {
                    console.warn("No English voices found, using browser default.");
                }
                
                utterance.rate = 0.9;
                utterance.onend = resolve;
                utterance.onerror = (e) => {
                    console.error("Speech synthesis error:", e);
                    reject(e);
                };

                // Workaround for browser bugs where speech can be cut off or not start
                speechSynthesis.cancel(); 
                setTimeout(() => {
                    speechSynthesis.speak(utterance);
                }, 100);
            });
        }

        async function playAudioQueue(scripts, statusEl, onFinish) {
            isSpeaking = true;
            for (let i = 0; i < scripts.length; i++) {
                if (!isSpeaking) {
                    console.log("Audio playback stopped by user.");
                    break; // User cancelled
                }
                if (statusEl) statusEl.textContent = `ƒêang ph√°t ƒëo·∫°n ${i + 1} / ${scripts.length}...`;
                try {
                    console.log(`Attempting to play audio for segment ${i + 1}: "${scripts[i].substring(0, Math.min(scripts[i].length, 50))}..."`); // Log start
                    await speakText(scripts[i]);
                    console.log(`Finished playing audio for segment ${i + 1}.`); // Log end
                    if (isSpeaking && i < scripts.length - 1) {
                        // Pause between audio clips
                        await new Promise(resolve => setTimeout(resolve, 1500));
                    }
                } catch (error) {
                    console.error(`L·ªói ph√°t √¢m thanh cho ƒëo·∫°n ${i + 1}:`, error);
                    if (statusEl) statusEl.textContent = `L·ªói ph√°t √¢m thanh ƒëo·∫°n ${i + 1}. Ti·∫øp t·ª•c...`;
                    // Do NOT break here. Continue to the next audio segment.
                    // Add a short delay to prevent rapid error logging if an issue persists
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            if (isSpeaking) {
                if (statusEl) statusEl.textContent = 'Ph·∫ßn nghe ƒë√£ k·∫øt th√∫c.';
            }
            isSpeaking = false;
            if (onFinish) onFinish();
            console.log("Audio queue processing finished.");
        }

        function handleAdvancedRecording() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                // Changed alert to a more user-friendly message in the UI
                const statusEl = document.getElementById('speaking-status');
                statusEl.textContent = 'L·ªói: Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ nh·∫≠n d·∫°ng gi·ªçng n√≥i.';
                statusEl.classList.add('text-red-500');
                return;
            }

            const startBtn = document.getElementById('start-record-btn');
            const stopBtn = document.getElementById('stop-record-btn');
            const statusEl = document.getElementById('speaking-status');

            if (isRecording) { // This means the stop button was clicked
                if (recognition) {
                    recognition.stop();
                }
                return;
            }

            // This means the start button was clicked
            recognition = new SpeechRecognition();
            recognition.lang = 'en-US';
            recognition.continuous = true; // Keep listening
            recognition.interimResults = true; // Show interim results

            recognition.onstart = () => {
                isRecording = true;
                accumulatedTranscript = '';
                startBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                statusEl.textContent = 'üî¥ ƒêang l·∫Øng nghe...';
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        accumulatedTranscript += event.results[i][0].transcript + ' ';
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                statusEl.textContent = `üî¥ ƒêang l·∫Øng nghe... (B·∫°n ƒë√£ n√≥i: ${interimTranscript})`;
            };
            
            recognition.onend = async () => {
                isRecording = false;
                startBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
                statusEl.textContent = 'ƒê√£ d·ª´ng ghi √¢m. ƒêang ch·∫•m ƒëi·ªÉm...';

                const taskPrompt = document.querySelector('.main-card[data-task-prompt]').dataset.taskPrompt;
                const analysisArea = document.getElementById('speaking-analysis-area');
                
                try {
                    const result = await analyzeSpeaking(taskPrompt, accumulatedTranscript);
                    analysisArea.innerHTML = `
                        <div class="pronunciation-score-card info-card">
                            <div class="score-circle">${result.score}</div>
                            <h4 class="card-title-alt">B·∫£n ghi ƒë√£ s·ª≠a</h4>
                            <p class="text-lg font-medium text-green-600 dark:text-green-400">"${result.corrected_transcript}"</p>
                            <h4 class="card-title-alt mt-4">ƒêi·ªÉm t·ªët</h4>
                            <p>${result.positive_points}</p>
                            <h4 class="card-title-alt mt-4">C·∫ßn c·∫£i thi·ªán</h4>
                            <p>${result.areas_for_improvement}</p>
                             <h4 class="card-title-alt mt-4">Nh·∫≠n x√©t chung</h4>
                            <p>${result.feedback}</p>
                        </div>
                    `;
                    analysisArea.classList.remove('hidden');
                } catch(e) {
                    analysisArea.innerHTML = `<p class="text-red-500 text-center font-bold">L·ªói ph√¢n t√≠ch b√†i n√≥i: ${e.message}</p>`;
                    analysisArea.classList.remove('hidden');
                }
                statusEl.textContent = 'ƒê√£ ch·∫•m ƒëi·ªÉm xong.';
            };
            
            recognition.onerror = (event) => {
                console.error("Recognition error:", event.error);
                statusEl.textContent = `L·ªói ghi √¢m: ${event.error}. Vui l√≤ng th·ª≠ l·∫°i.`;
                isRecording = false;
                startBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
            };

            recognition.start();
        }

    </script>
</body>
</html>
